# 풀이

사용 알고리즘 : DFS<br>
백준 예상티어 : 실버 2 ~ 골드 5

```c++
#include <iostream>

using namespace std;

void fastio();
void input();
void solution();
void output();

int N, M, arr[1001][1001], b, result;
int prob[1001][1001];

int main() {
    fastio();
    input();
    solution();
    output();
}

void fastio() {
    cin.tie(0);
    ios_base::sync_with_stdio(0);
}

void input() {
    cin >> N >> M;

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            cin >> arr[i][j];
            // 공이 있는 위치를 저장
            if (arr[i][j] == 2) b = j;
        }
    }
}

void dfs(int x, int y, int cnt) {
    // 공이 가장 아래에 도착
    if (x == N - 1) {
        prob[y][cnt]++;
        result = 0;
    }
    else {
        // 바로 아래에 못이 있는 경우
        if (arr[x + 1][y] == 1) {
            if (arr[x + 1][y - 1] != 1 && arr[x][y - 1] != 1) dfs(x, y - 1, cnt + 1);
            if (arr[x + 1][y + 1] != 1 && arr[x][y + 1] != 1) dfs(x, y + 1, cnt + 1);
        }
        // 못이 없는 경우
        else dfs(x + 1, y, cnt);
    }
}

void make_prob() {
    for (int i = 0; i < M; i++) {
        for (int j = 1000; j > 0; j--) {
            prob[i][j - 1] += prob[i][j] / 2;
            prob[i][j] %= 2;
        }
    }
}

int max_prob() {
    int ans = 0;

    for (int i = 1; i < M; i++) {
        for (int j = 0; j < 1000; j++) {
            if (prob[ans][j] != prob[i][j]) {
                if (prob[ans][j] < prob[i][j]) ans = i;
                break;
            }
        }
    }

    return ans;
}

void solution() {
    dfs(0, b, 0);

    if (result == 0) {
        make_prob();
        result = max_prob();
    }
}

void output() {
    cout << result;
}
```
