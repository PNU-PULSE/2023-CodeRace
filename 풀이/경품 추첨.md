# 풀이
```c++
#include <iostream>

using namespace std;

void fastio();
void input();
void solution();
void output();

int N, M, arr[1001][1001], b, result;
int prob[1001][1001];

int main() {
    fastio();
    input();
    solution();
    output();
}

void fastio() {
    cin.tie(0);
    ios_base::sync_with_stdio(0);
}

void input() {
    cin >> N >> M;

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            cin >> arr[i][j];
            // 공이 있는 위치를 저장
            if (arr[i][j] == 2) b = j;
        }
    }
}

void dfs(int x, int y, int cnt) {
    // 공이 가장 아래에 도착
    if (x == N - 1) {
        prob[y][cnt]++;
        result = 0;
    }
    else {
        // 바로 아래에 못이 있는 경우
        if (arr[x + 1][y] == 1) {
            if (arr[x + 1][y - 1] != 1 && arr[x][y - 1] != 1) dfs(x, y - 1, cnt + 1);
            if (arr[x + 1][y + 1] != 1 && arr[x][y + 1] != 1) dfs(x, y + 1, cnt + 1);
        }
        // 못이 없는 경우
        else dfs(x + 1, y, cnt);
    }
}

void make_prob() {
    for (int i = 0; i < M; i++) {
        for (int j = 1000; j > 0; j--) {
            prob[i][j - 1] += prob[i][j] / 2;
            prob[i][j] %= 2;
        }
    }
}

int max_prob() {
    int ans = 0;

    for (int i = 1; i < M; i++) {
        for (int j = 0; j < 1000; j++) {
            if (prob[ans][j] != prob[i][j]) {
                if (prob[ans][j] < prob[i][j]) ans = i;
                break;
            }
        }
    }

    return ans;
}

void solution() {
    dfs(0, b, 0);

    if (result == 0) {
        make_prob();
        result = max_prob();
    }
}

void output() {
    cout << result;
}
```

### 입력/출력
```
4 4
2 0 0 0
0 0 0 0
0 1 0 0
0 0 0 0
```
```
출력 : 0
```

```
4 4
0 2 0 0
0 0 0 0
0 1 0 0 
0 0 0 0
```
```
출력 : 0
```

```
3 5
0 0 2 0 0
0 1 1 1 0
0 0 0 0 0
```
```
출력 : -1
```

```
6 6
0 0 0 2 0 0
0 0 0 0 0 0
0 0 0 1 0 0
0 0 0 0 0 0
0 0 1 0 1 0
0 0 0 0 0 0
```
```
출력 : 3
```

```
6 6
0 0 0 2 0 0
0 0 0 0 0 0
0 0 0 1 1 0
0 0 0 0 0 0
0 0 1 0 1 0
0 0 0 0 0 0
```
```
출력 : 1
```

```
10 10
0 0 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 
0 0 0 1 0 1 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 
0 0 1 0 1 0 1 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```
```
출력 : 5
```

간단한 DFS 문제입니다.

확률 계산을 하려면 2^1000의 값이 필요하기 때문에 다른 방법으로 계산을 수행하였습니다.

공이 가장 아래에 도착했을 때의 cnt를 확률 값처럼 사용할 수 있습니다. (1 / 2 ^ cnt)

따라서 도착했을 때마다 각 cnt의 개수를 갱신하여 확률을 저장하였습니다. 

저장된 cnt의 개수를 비교하여, 어떤 번호가 확률이 더 높은지 구했습니다.

문제를 좀 더 명확하게 만들기 위해 주어진 조건을 변경했습니다.
(못 주변 8칸이 항상 빈 공간 -> 못이 붙어 있는 경우 갈 수 없음)

실버 2 ~ 골드 5
