# 풀이
```c++
#include <iostream>

using namespace std;

void fastio();
void input();
void solution();
void output();

int N, M, arr[1000][1000], b, min_cnt = 1000, result = -1;

int main() {
    fastio();
    input();
    solution();
    output();
}

void fastio() {
    cin.tie(0);
    ios_base::sync_with_stdio(0);
}

void input() {
    cin >> N >> M;

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            cin >> arr[i][j];
            // 공이 있는 위치를 저장
            if (arr[i][j] == 2) b = j;
        }
    }
}

void dfs(int x, int y, int cnt) {
    // 공이 가장 아래에 도착
    if (x == N - 1) {
        // 못을 더 적게 만난 경우 갱신
        if (min_cnt > cnt) {
            min_cnt = cnt;
            result = y;
        }
    }
    else {
        // 바로 아래에 못이 있는 경우
        if (arr[x + 1][y] == 1) {
            if (arr[x + 1][y - 1] != 1 && arr[x][y - 1] != 1) dfs(x, y - 1, cnt + 1);
            if (arr[x + 1][y + 1] != 1 && arr[x][y + 1] != 1) dfs(x, y + 1, cnt + 1);
        }
        // 못이 없는 경우
        else dfs(x + 1, y, cnt);
    }
}

void solution() {
    dfs(0, b, 0);
}

void output() {
    cout << result;
}
```

### 입력/출력
```
4 4
2 0 0 0
0 0 0 0
0 1 0 0
0 0 0 0
```
```
출력 : 0
```

```
4 4
0 2 0 0
0 0 0 0
0 1 0 0 
0 0 0 0
```
```
출력 : 0
```

```
3 5
0 0 2 0 0
0 1 1 1 0
0 0 0 0 0
```
```
출력 : -1
```

```
6 6
0 0 0 2 0 0
0 0 0 0 0 0
0 1 1 1 0 0
0 0 0 0 0 0
0 0 1 0 1 0
0 0 0 0 0 0
```
```
출력 : 3
```

간단한 DFS 문제입니다.

못을 만날때마다 경우의 수가 추가되어 확률은 줄어들기 때문에 못을 가장 적게 만나는 경로를 찾아 출력합니다.

문제를 좀 더 명확하게 만들기 위해 주어진 조건을 변경했습니다.
(못 주변 8칸이 항상 빈 공간 -> 못이 붙어 있는 경우 갈 수 없음)

실버 2 ~ 골드 5
